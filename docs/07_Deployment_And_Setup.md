# 7. Развертывание и настройка (с использованием Docker)

## 7.1. Требования к окружению для запуска Docker

*   **Docker Desktop** (для Windows, macOS) или **Docker Engine** (для Linux) установленный и запущенный.
*   **Docker Compose** (обычно поставляется с Docker Desktop; для Linux может требоваться отдельная установка `docker-compose-plugin` или `docker compose` CLI).
*   Доступ в интернет для скачивания образов (например, `postgres`, `nginx`, базовых образов .NET и Node.js) при первой сборке/запуске.
*   Достаточное количество ресурсов (ОЗУ, место на диске) для запуска контейнеров.

## 7.2. Структура Docker-конфигурации

Проект использует `docker-compose.yml` в корневой директории для оркестрации трех основных сервисов:
*   **`db`**: Контейнер с базой данных PostgreSQL.
*   **`server`**: Контейнер с бэкенд-приложением ASP.NET Core.
*   **`client`**: Контейнер с фронтенд-приложением React, обслуживаемым через Nginx.

Каждый сервис (`server` и `client`) имеет свой `Dockerfile`:
*   `Server/SeaBattle/Dockerfile`: Определяет сборку .NET приложения и его запуск.
*   `client/Dockerfile`: Определяет сборку React-приложения (Node.js) и настройку Nginx для его обслуживания.

## 7.3. Сборка и запуск приложения через Docker Compose

1.  **Клонировать репозиторий** (если еще не сделано).
2.  **Перейти в корневую директорию проекта**, где находится файл `docker-compose.yml`.
3.  **Выполнить команду для сборки образов и запуска контейнеров:**
    ```bash
    docker compose up --build
    ```
    *   Флаг `--build` пересобирает образы, если в Dockerfile или исходном коде были изменения. Для последующих запусков без изменений можно использовать `docker compose up`.
    *   Чтобы запустить контейнеры в фоновом режиме (detached mode), добавьте флаг `-d`:
        ```bash
        docker compose up --build -d
        ```
4.  **Ожидание запуска:** Docker Compose сначала соберет образы (если их нет или указан `--build`), затем запустит контейнеры в указанном порядке зависимостей (`server` ждет `db`). Процесс может занять некоторое время при первом запуске.
5.  **Проверка логов (если не в detached mode):** В консоли будут отображаться логи всех запущенных контейнеров. Если запущен в detached mode, логи можно посмотреть командой `docker compose logs <service_name>` (например, `docker compose logs server`).

## 7.4. Доступ к приложению

*   **Фронтенд (React-приложение):** После успешного запуска, приложение должно быть доступно в веб-браузере по адресу, указанному для сервиса `client` в `docker-compose.yml` (обычно это `http://localhost` или `http://localhost:PORT`, где `PORT` - это порт, проброшенный с хоста на контейнер Nginx, например, 80 или 3000).
*   **Бэкенд API:** Напрямую обращаться к API бэкенда обычно не требуется, так как фронтенд настроен на взаимодействие с ним внутри Docker-сети. Однако, если порт API (например, 8080 для Kestrel) проброшен в `docker-compose.yml`, его эндпоинты также могут быть доступны с хост-машины (например, `http://localhost:8080/api/...`).

## 7.5. Конфигурация через переменные окружения

Большинство настроек управляется через переменные окружения, определенные в `docker-compose.yml`:

*   **Для сервиса `db` (PostgreSQL):**
    *   `POSTGRES_USER`: Имя пользователя базы данных.
    *   `POSTGRES_PASSWORD`: Пароль пользователя базы данных.
    *   `POSTGRES_DB`: Имя создаваемой базы данных.
*   **Для сервиса `server` (ASP.NET Core):**
    *   `ASPNETCORE_ENVIRONMENT`: Устанавливается в `Development` или `Production`.
    *   `ASPNETCORE_URLS`: Определяет URL, на котором слушает Kestrel внутри контейнера (например, `http://+:8080`).
    *   `ConnectionStrings__DefaultConnection`: Строка подключения к базе данных. **Важно:** здесь используется имя сервиса `db` как хост (`Host=db`), так как контейнеры находятся в одной Docker-сети.
    *   Другие настройки из `appsettings.json` могут быть переопределены переменными окружения (например, `Jwt__Key`, `Jwt__Issuer`).
*   **Для сервиса `client` (React/Nginx):**
    *   В `client/Dockerfile` или конфигурации Nginx может быть настроен URL для проксирования API-запросов к сервису `server`, если это необходимо.
    *   React-приложение (Vite) может использовать переменные окружения, начинающиеся с `VITE_` (например, `VITE_API_BASE_URL`), которые должны быть установлены на этапе сборки образа клиента или переданы в Nginx для динамической конфигурации (если это поддерживается).

## 7.6. Миграции базы данных (EF Core)

*   Миграции EF Core **автоматически применяются при запуске контейнера `server`**. Это реализовано в `Program.cs` бэкенд-приложения путем вызова `dbContext.Database.Migrate()`.
*   Для создания новых миграций (если вы разработчик и изменяете модели данных):
    1.  Убедитесь, что ваше локальное окружение разработки (не в Docker) может подключиться к базе данных (возможно, запущенной через `docker compose up db`).
    2.  Из директории проекта `Server/SeaBattle` (где находится `.csproj` файл) выполните:
        ```bash
        dotnet ef migrations add ИмяНовойМиграции -o Data/Migrations
        ```
    3.  После добавления миграции, пересоберите Docker-образ сервера (`docker compose build server` или `docker compose up --build server`), чтобы изменения кода и новые файлы миграций были включены в образ.

## 7.7. Остановка приложения

*   Чтобы остановить все запущенные контейнеры, выполните в директории с `docker-compose.yml`:
    ```bash
    docker compose down
    ```
*   Эта команда остановит и удалит контейнеры. Если вы хотите сохранить данные в PostgreSQL между запусками, том (volume) для данных (`pgdata` в `docker-compose.yml`) обеспечит их персистентность.

## 7.8. Устранение неполадок

*   **Проверьте логи контейнеров:** `docker compose logs <service_name>`.
*   **Убедитесь, что порты не заняты:** Если `docker compose up` жалуется на занятый порт, измените его в `docker-compose.yml` (например, `80:81` вместо `80:80`).
*   **Проблемы с подключением к БД:** Убедитесь, что сервис `db` запущен и здоров, и что строка подключения в `server` использует правильное имя хоста (`db`).
*   **Ошибки сборки образов:** Проверьте вывод команды `docker compose build` и соответствующие `Dockerfile` на наличие ошибок. 